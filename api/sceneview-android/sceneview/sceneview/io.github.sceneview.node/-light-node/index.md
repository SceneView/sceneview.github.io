//[sceneview](../../../index.md)/[io.github.sceneview.node](../index.md)/[LightNode](index.md)

# LightNode

[androidJvm]\
open class [LightNode](index.md) : [Node](../-node/index.md)

###  A Node represents a transformation within the scene graph's hierarchy.

This node contains a light for the rendering engine to render.

Each node can have an arbitrary number of child nodes and one parent. The parent may be another node, or the scene.

## Constructors

| | |
|---|---|
| [LightNode](-light-node.md) | [androidJvm]<br>fun [LightNode](-light-node.md)(position: [Position](../../io.github.sceneview.math/index.md#945960193%2FClasslikes%2F-1571379623) = DEFAULT_POSITION, rotation: [Rotation](../../io.github.sceneview.math/index.md#1133844556%2FClasslikes%2F-1571379623) = DEFAULT_ROTATION, scale: [Scale](../../io.github.sceneview.math/index.md#2055938798%2FClasslikes%2F-1571379623) = DEFAULT_SCALE) |
| [LightNode](-light-node.md) | [androidJvm]<br>fun [LightNode](-light-node.md)(light: [Light](../../com.google.ar.sceneform.rendering/-light/index.md))<br>TODO : Doc |
| [LightNode](-light-node.md) | [androidJvm]<br>fun [LightNode](-light-node.md)(lightInstance: [LightInstance](../../com.google.ar.sceneform.rendering/-light-instance/index.md))<br>TODO : Doc |

## Functions

| Name | Summary |
|---|---|
| [addChild](../-node-parent/add-child.md) | [androidJvm]<br>@[UiThread](https://developer.android.com/reference/kotlin/androidx/annotation/UiThread.html)<br>open fun [addChild](../-node-parent/add-child.md)(child: [Node](../-node/index.md)): [Node](../-node/index.md)<br>Adds a node as a child of this NodeParent. If the node already has a parent, it is removed from its old parent. If the node is already a direct child of this NodeParent, no change is made. |
| [callOnHierarchy](../-node-parent/call-on-hierarchy.md) | [androidJvm]<br>open fun [callOnHierarchy](../-node-parent/call-on-hierarchy.md)(action: ([Node](../-node/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html))<br>Traversal is depth first. If this NodeParent is a Node, traversal starts with this NodeParent, otherwise traversal starts with its children. |
| [clone](clone.md) | [androidJvm]<br>open override fun [clone](clone.md)(): [LightNode](index.md) |
| [copy](copy.md) | [androidJvm]<br>fun [copy](copy.md)(toNode: [LightNode](index.md) = LightNode()): [LightNode](index.md)<br>@[JvmOverloads](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index.html)<br>open fun [copy](../-node/copy.md)(toNode: [Node](../-node/index.md) = Node()): [Node](../-node/index.md) |
| [destroy](destroy.md) | [androidJvm]<br>open override fun [destroy](destroy.md)() |
| [dispatchTouchEvent](../-node/dispatch-touch-event.md) | [androidJvm]<br>open fun [dispatchTouchEvent](../-node/dispatch-touch-event.md)(pickHitResult: [PickHitResult](../../com.google.ar.sceneform/-pick-hit-result/index.md), motionEvent: [MotionEvent](https://developer.android.com/reference/kotlin/android/view/MotionEvent.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Used by TouchEventSystem to dispatch touch events. |
| [doOnAttachedToScene](../-node/do-on-attached-to-scene.md) | [androidJvm]<br>fun [doOnAttachedToScene](../-node/do-on-attached-to-scene.md)(action: (scene: [SceneView](../../io.github.sceneview/-scene-view/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html))<br>If the node is already attached the action will be performed immediately. Else this action will be invoked the first time the scene is attached. |
| [getSceneViewInternal](../-node/get-scene-view-internal.md) | [androidJvm]<br>fun [getSceneViewInternal](../-node/get-scene-view-internal.md)(): [SceneView](../../io.github.sceneview/-scene-view/index.md)? |
| [getTransformationMatrix](../-node/get-transformation-matrix.md) | [androidJvm]<br>open override fun [getTransformationMatrix](../-node/get-transformation-matrix.md)(): [Matrix](../../com.google.ar.sceneform.math/-matrix/index.md) |
| [isDescendantOf](../-node/is-descendant-of.md) | [androidJvm]<br>fun [isDescendantOf](../-node/is-descendant-of.md)(ancestor: [NodeParent](../-node-parent/index.md)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Return true if the node is an ancestor of this node |
| [onAttachToScene](../-node/on-attach-to-scene.md) | [androidJvm]<br>open fun [onAttachToScene](../-node/on-attach-to-scene.md)(sceneView: [SceneView](../../io.github.sceneview/-scene-view/index.md)) |
| [onChildAdded](../-node/on-child-added.md) | [androidJvm]<br>open override fun [onChildAdded](../-node/on-child-added.md)(child: [Node](../-node/index.md)) |
| [onChildRemoved](../-node/on-child-removed.md) | [androidJvm]<br>open override fun [onChildRemoved](../-node/on-child-removed.md)(child: [Node](../-node/index.md)) |
| [onCreate](../-view-node/index.md#139941652%2FFunctions%2F-1571379623) | [androidJvm]<br>open override fun [onCreate](../-view-node/index.md#139941652%2FFunctions%2F-1571379623)(@[NonNull](https://developer.android.com/reference/kotlin/androidx/annotation/NonNull.html)p0: [LifecycleOwner](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleOwner.html)) |
| [onDestroy](../-node/on-destroy.md) | [androidJvm]<br>open override fun [onDestroy](../-node/on-destroy.md)(owner: [LifecycleOwner](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleOwner.html)) |
| [onDetachFromScene](../-node/on-detach-from-scene.md) | [androidJvm]<br>open fun [onDetachFromScene](../-node/on-detach-from-scene.md)(sceneView: [SceneView](../../io.github.sceneview/-scene-view/index.md)) |
| [onFrame](../-node/on-frame.md) | [androidJvm]<br>open override fun [onFrame](../-node/on-frame.md)(frameTime: [FrameTime](../../io.github.sceneview.utils/-frame-time/index.md)) |
| [onLightChanged](on-light-changed.md) | [androidJvm]<br>open fun [onLightChanged](on-light-changed.md)() |
| [onPause](../-view-node/index.md#187777572%2FFunctions%2F-1571379623) | [androidJvm]<br>open override fun [onPause](../-view-node/index.md#187777572%2FFunctions%2F-1571379623)(@[NonNull](https://developer.android.com/reference/kotlin/androidx/annotation/NonNull.html)p0: [LifecycleOwner](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleOwner.html)) |
| [onRenderingChanged](../-node/on-rendering-changed.md) | [androidJvm]<br>open fun [onRenderingChanged](../-node/on-rendering-changed.md)(isRendering: [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html))<br>A Node is rendered if it's visible, part of a scene, and its parent is rendered. Override to perform any setup that needs to occur when the node is active or not. |
| [onResume](../-view-node/index.md#-1807945979%2FFunctions%2F-1571379623) | [androidJvm]<br>open override fun [onResume](../-view-node/index.md#-1807945979%2FFunctions%2F-1571379623)(@[NonNull](https://developer.android.com/reference/kotlin/androidx/annotation/NonNull.html)p0: [LifecycleOwner](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleOwner.html)) |
| [onStart](../-view-node/index.md#1240777104%2FFunctions%2F-1571379623) | [androidJvm]<br>open override fun [onStart](../-view-node/index.md#1240777104%2FFunctions%2F-1571379623)(@[NonNull](https://developer.android.com/reference/kotlin/androidx/annotation/NonNull.html)p0: [LifecycleOwner](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleOwner.html)) |
| [onStop](../-view-node/index.md#487071706%2FFunctions%2F-1571379623) | [androidJvm]<br>open override fun [onStop](../-view-node/index.md#487071706%2FFunctions%2F-1571379623)(@[NonNull](https://developer.android.com/reference/kotlin/androidx/annotation/NonNull.html)p0: [LifecycleOwner](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleOwner.html)) |
| [onSurfaceChanged](../../io.github.sceneview/-scene-lifecycle-observer/on-surface-changed.md) | [androidJvm]<br>open fun [onSurfaceChanged](../../io.github.sceneview/-scene-lifecycle-observer/on-surface-changed.md)(width: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html), height: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html))<br>Records a change in surface dimensions. |
| [onTouchEvent](../-node/on-touch-event.md) | [androidJvm]<br>fun [onTouchEvent](../-node/on-touch-event.md)(pickHitResult: [PickHitResult](../../com.google.ar.sceneform/-pick-hit-result/index.md), motionEvent: [MotionEvent](https://developer.android.com/reference/kotlin/android/view/MotionEvent.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Override to perform any logic that should occur when this node is touched. The way that touch events are propagated mirrors the way touches are propagated to Android Views. This is only called when the node is active. |
| [onTransformChanged](../-node/on-transform-changed.md) | [androidJvm]<br>open fun [onTransformChanged](../-node/on-transform-changed.md)()<br>If node A's position is changed, then that will trigger [onTransformChanged](../-node/on-transform-changed.md) to be called for all of it's descendants. |
| [removeChild](../-node-parent/remove-child.md) | [androidJvm]<br>open fun [removeChild](../-node-parent/remove-child.md)(child: [Node](../-node/index.md)): [Node](../-node/index.md)<br>Removes a node from the children of this NodeParent. If the node is not a direct child of this NodeParent, no change is made. |
| [scale](../-node/scale.md) | [androidJvm]<br>fun [scale](../-node/scale.md)(scale: [Float](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)) |
| [setLight](set-light.md) | [androidJvm]<br>fun [setLight](set-light.md)(light: [Light](../../com.google.ar.sceneform.rendering/-light/index.md)?): [LightInstance](../../com.google.ar.sceneform.rendering/-light-instance/index.md)? |
| [smooth](../-node/smooth.md) | [androidJvm]<br>fun [smooth](../-node/smooth.md)(position: [Position](../../io.github.sceneview.math/index.md#945960193%2FClasslikes%2F-1571379623) = this.position, quaternion: [Quaternion](../../dev.romainguy.kotlin.math/-quaternion/index.md) = this.quaternion, rotation: [Rotation](../../io.github.sceneview.math/index.md#1133844556%2FClasslikes%2F-1571379623) = this.rotation, speed: [Float](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html) = this.smoothSpeed) |
| [transform](../-node/transform.md) | [androidJvm]<br>fun [transform](../-node/transform.md)(position: [Position](../../io.github.sceneview.math/index.md#945960193%2FClasslikes%2F-1571379623) = this.position, quaternion: [Quaternion](../../dev.romainguy.kotlin.math/-quaternion/index.md) = this.quaternion, rotation: [Rotation](../../io.github.sceneview.math/index.md#1133844556%2FClasslikes%2F-1571379623) = this.rotation, scale: [Scale](../../io.github.sceneview.math/index.md#2055938798%2FClasslikes%2F-1571379623) = this.scale) |

## Properties

| Name | Summary |
|---|---|
| [_children](../-node/_children.md) | [androidJvm]<br>open override var [_children](../-node/_children.md): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Node](../-node/index.md)&gt; |
| [allChildren](../-node-parent/all-children.md) | [androidJvm]<br>open val [allChildren](../-node-parent/all-children.md): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Node](../-node/index.md)&gt;<br>Traversal is depth first. If this NodeParent is a Node, traversal starts with this NodeParent, otherwise traversal starts with its children. |
| [children](../-node-parent/children.md) | [androidJvm]<br>open var [children](../-node-parent/children.md): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Node](../-node/index.md)&gt; |
| [collider](../-node/collider.md) | [androidJvm]<br>var [collider](../-node/collider.md): [Collider](../../com.google.ar.sceneform.collision/-collider/index.md)? = null |
| [collisionShape](../-node/collision-shape.md) | [androidJvm]<br>var [collisionShape](../-node/collision-shape.md): [CollisionShape](../../com.google.ar.sceneform.collision/-collision-shape/index.md)? = null<br>If the shape is not set and renderable is set, then [Renderable.getCollisionShape](../../com.google.ar.sceneform.rendering/-view-renderable/index.md#111252609%2FFunctions%2F-1571379623) is used to detect collisions for this [Node](../-node/index.md). |
| [hierarchy](../-node-parent/hierarchy.md) | [androidJvm]<br>open val [hierarchy](../-node-parent/hierarchy.md): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Node](../-node/index.md)&gt;<br>Traversal is depth first. If this NodeParent is a Node, traversal starts with this NodeParent, otherwise traversal starts with its children. |
| [isAttached](../-node/is-attached.md) | [androidJvm]<br>val [isAttached](../-node/is-attached.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [isFocusable](../-node/is-focusable.md) | [androidJvm]<br>var [isFocusable](../-node/is-focusable.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) = true<br>when a touch event happened |
| [isRendered](is-rendered.md) | [androidJvm]<br>open override var [isRendered](is-rendered.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [isVisible](../-node/is-visible.md) | [androidJvm]<br>open var [isVisible](../-node/is-visible.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) = true<br>Note that a Node may be enabled but still inactive if it isn't part of the scene or if its parent is inactive. |
| [light](light.md) | [androidJvm]<br>val [light](light.md): [Light](../../com.google.ar.sceneform.rendering/-light/index.md)? |
| [lightInstance](light-instance.md) | [androidJvm]<br>var [lightInstance](light-instance.md): [LightInstance](../../com.google.ar.sceneform.rendering/-light-instance/index.md)? = null<br>To use, first create a [Light](../../com.google.ar.sceneform.rendering/-light/index.md). Set the parameters you care about and then attach it to the node using this function. A node may have a renderable and a light or just act as a [Light](../../com.google.ar.sceneform.rendering/-light/index.md). |
| [onAttachedToScene](../-node/on-attached-to-scene.md) | [androidJvm]<br>val [onAttachedToScene](../-node/on-attached-to-scene.md): [MutableList](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)&lt;(scene: [SceneView](../../io.github.sceneview/-scene-view/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt; |
| [onChildAdded](../-node-parent/on-child-added.md) | [androidJvm]<br>open val [onChildAdded](../-node-parent/on-child-added.md): ([Node](../-node/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)? |
| [onChildRemoved](../-node-parent/on-child-removed.md) | [androidJvm]<br>open val [onChildRemoved](../-node-parent/on-child-removed.md): ([Node](../-node/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)? |
| [onDetachedFromScene](../-node/on-detached-from-scene.md) | [androidJvm]<br>val [onDetachedFromScene](../-node/on-detached-from-scene.md): [MutableList](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)&lt;(scene: [SceneView](../../io.github.sceneview/-scene-view/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt; |
| [onFrame](../-node/on-frame.md) | [androidJvm]<br>val [onFrame](../-node/on-frame.md): [MutableList](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)&lt;(frameTime: [FrameTime](../../io.github.sceneview.utils/-frame-time/index.md), node: [Node](../-node/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt; |
| [onRenderingChanged](../-node/on-rendering-changed.md) | [androidJvm]<br>val [onRenderingChanged](../-node/on-rendering-changed.md): [MutableList](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)&lt;(node: [Node](../-node/index.md), isRendering: [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt; |
| [onTouched](../-node/on-touched.md) | [androidJvm]<br>var [onTouched](../-node/on-touched.md): (pickHitResult: [PickHitResult](../../com.google.ar.sceneform/-pick-hit-result/index.md), motionEvent: [MotionEvent](https://developer.android.com/reference/kotlin/android/view/MotionEvent.html)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)? = null<br>If there is a callback registered, then touch events will not bubble to this node's parent. If the Node.onTouchEvent is overridden and super.onTouchEvent is not called, then the tap will not occur. |
| [onTouchEvent](../-node/on-touch-event.md) | [androidJvm]<br>var [onTouchEvent](../-node/on-touch-event.md): (pickHitResult: [PickHitResult](../../com.google.ar.sceneform/-pick-hit-result/index.md), motionEvent: [MotionEvent](https://developer.android.com/reference/kotlin/android/view/MotionEvent.html)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)? = null<br>The way that touch events are propagated mirrors the way touches are propagated to Android Views. This is only called when the node is active. |
| [onTransformChanged](../-node/on-transform-changed.md) | [androidJvm]<br>val [onTransformChanged](../-node/on-transform-changed.md): [MutableList](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)&lt;(node: [Node](../-node/index.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt;<br>If node A's position is changed, then that will trigger [onTransformChanged](../-node/on-transform-changed.md) to be called for all of it's descendants. |
| [parent](../-node/parent.md) | [androidJvm]<br>var [parent](../-node/parent.md): [NodeParent](../-node-parent/index.md)? = null<br>If set to null, this node will be detached ([removeChild](../../../../sceneview/io.github.sceneview.node/-node/remove-child.md)) from its parent. |
| [parentNode](../-node/parent-node.md) | [androidJvm]<br>val [parentNode](../-node/parent-node.md): [Node](../-node/index.md)?<br>Returns null if the parent is not a [Node](../-node/index.md). = Returns null if the parent is a [SceneView](../../io.github.sceneview/-scene-view/index.md) |
| [position](../-node/position.md) | [androidJvm]<br>var [position](../-node/position.md): [Position](../../io.github.sceneview.math/index.md#945960193%2FClasslikes%2F-1571379623)<br>The node's position locates it within the coordinate system of its parent. The default position is the zero vector, indicating that the node is placed at the origin of the parent node's coordinate system. |
| [quaternion](../-node/quaternion.md) | [androidJvm]<br>var [quaternion](../-node/quaternion.md): [Quaternion](../../dev.romainguy.kotlin.math/-quaternion/index.md)<br>TODO: Doc |
| [rotation](../-node/rotation.md) | [androidJvm]<br>var [rotation](../-node/rotation.md): [Rotation](../../io.github.sceneview.math/index.md#1133844556%2FClasslikes%2F-1571379623)<br>[0..360] |
| [scale](../-node/scale.md) | [androidJvm]<br>var [scale](../-node/scale.md): [Scale](../../io.github.sceneview.math/index.md#2055938798%2FClasslikes%2F-1571379623) |
| [smoothRotationThreshold](../-node/smooth-rotation-threshold.md) | [androidJvm]<br>var [smoothRotationThreshold](../-node/smooth-rotation-threshold.md): [Float](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)<br>This is used to avoid very near rotations smooth modifications. It prevents the rotation to appear too quick if the ranges are too close and uses linearly interpolation for upper dot products. |
| [smoothSpeed](../-node/smooth-speed.md) | [androidJvm]<br>var [smoothSpeed](../-node/smooth-speed.md): [Float](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html) = 5.0f<br>Expressed in units per seconds. On an AR context, 1 unit = 1 meter. So, for position, this value defines the meters per seconds for a node move. This value is used by [smooth](../-node/smooth.md) |
| [transform](../-node/transform.md) | [androidJvm]<br>open var [transform](../-node/transform.md): [Transform](../../io.github.sceneview.math/index.md#1875660684%2FClasslikes%2F-1571379623) |
| [transformationMatrixInverted](../-node/transformation-matrix-inverted.md) | [androidJvm]<br>open val [transformationMatrixInverted](../-node/transformation-matrix-inverted.md): [Matrix](../../com.google.ar.sceneform.math/-matrix/index.md) |
| [worldPosition](../-node/world-position.md) | [androidJvm]<br>open val [worldPosition](../-node/world-position.md): [Position](../../io.github.sceneview.math/index.md#945960193%2FClasslikes%2F-1571379623)<br>The world position of this node (i.e. relative to the [SceneView](../../io.github.sceneview/-scene-view/index.md)). This is the composition of this component's local position with its parent's world position. |
| [worldRotation](../-node/world-rotation.md) | [androidJvm]<br>open val [worldRotation](../-node/world-rotation.md): [Rotation](../../io.github.sceneview.math/index.md#1133844556%2FClasslikes%2F-1571379623)<br>The world rotation of this node (i.e. relative to the [SceneView](../../io.github.sceneview/-scene-view/index.md)). This is the composition of this component's local rotation with its parent's world rotation. |
| [worldScale](../-node/world-scale.md) | [androidJvm]<br>open val [worldScale](../-node/world-scale.md): [Scale](../../io.github.sceneview.math/index.md#2055938798%2FClasslikes%2F-1571379623)<br>The world scale of this node (i.e. relative to the [SceneView](../../io.github.sceneview/-scene-view/index.md)). This is the composition of this component's local scale with its parent's world scale. |
| [worldTransform](../-node/world-transform.md) | [androidJvm]<br>open val [worldTransform](../-node/world-transform.md): [Mat4](../../dev.romainguy.kotlin.math/-mat4/index.md) |
